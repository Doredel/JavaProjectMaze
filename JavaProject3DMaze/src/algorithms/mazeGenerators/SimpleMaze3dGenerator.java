package algorithms.mazeGenerators;

import java.util.Random;

public class SimpleMaze3dGenerator extends CommonMaze3dGenerator {

	/**
	 * <strong>generate</strong>
	 * <p>
	 * <code>public Maze3d generate(int width, int height, int depth)</code>
	 * <p>
	 * The function generate a {@link Maze3d} using naive algorithms 
	 * @param width - the width of the maze (for x values)
	 * @param height - the height of the maze (for y values)
	 * @param depth - the depth of the maze (for z values)
	 * @return {@link Maze3d} - a maze that have been randomly generated by a naive algorithm
	 */
	@Override
	public Maze3d generate(int width, int height, int depth) {
		Random rnd = new Random();
		
		Maze3d maze = new Maze3d();
		maze.setMaze3d(new int[width][height][depth]);
		
		//generating a start and end to the maze
		Position start = new Position(rnd.nextInt(width),rnd.nextInt(height),rnd.nextInt(depth));
		Position end = new Position(rnd.nextInt(width),rnd.nextInt(height),rnd.nextInt(depth));
		
		//generating the number of open cells (value of 0)
		int num = rnd.nextInt(width*height*depth);
		
		//calculating the distance between the start and the end
		int minX=Math.min(start.getX(),end.getX());
		int maxX=Math.max(start.getX(),end.getX());
		int minY=Math.min(start.getY(),end.getY());
		int maxY=Math.max(start.getY(),end.getY());
		int minZ=Math.min(start.getZ(),end.getZ());
		int maxZ=Math.max(start.getZ(),end.getZ());
		
		
		//initiating the maze with walls
		initMaze(maze);
		
		//Scattering the cells
		for (int i = 0; i < num; i++) {
			maze.setValue(rnd.nextInt(width),rnd.nextInt(height),rnd.nextInt(depth),0);
		}
		
		//forcing a route between the start and the end
		for (int i = minX; i <= maxX; i++) {
			maze.setValue(i,start.getY(),start.getZ(),0);
		}
		for (int j = minY; j <= maxY; j++) {
			maze.setValue(start.getX(),j,start.getZ(),0);
		}
		for (int k = minZ; k <= maxZ; k++) {
			maze.setValue(start.getX(),start.getY(),k,0);
		}

		maze.setGoalPosition(end);
		maze.setStartPosition(start);
		
		
		return maze;
	}

}
